#!/bin/sh

# Main ├────────────────────────────────────────────────────────────────────────

main() {
  local number_tests=0
  local number_failures=0
  local dirs=$@
  local test=$(pwd)
  local work=$(mktemp --directory)
  cp --recursive . $work
  trap "rm --recursive $work" EXIT
  for dir in $(find $dirs -type d); do
    cd $test/$dir;
    local test_files=$(find * -name out -o -name selections -o -name state)
    cd $work/$dir;
    IFS=¬
    local indent=$(repeat ' ' $(pwd | sed "s|$test||" | tr --delete --complement / | awk '{ print length }'))
    local name=$(basename $PWD)
    if ! exists cmd; then
      echo "$indent$name"
    else
      ((number_tests++))
      touch in; cp in out
      local kak_commands="
        set global autoreload yes
        try %{
        source rc
        }
        try %{
        exec '%s%[(](.+?)[)]<ret>i<del><del><esc>a<backspace><c-u><esc>'
        } \
        catch %{
        exec gg
        }
        exec '$(<cmd)'
        eval -buffer *debug* write debug
        nop %sh{ IFS==
        echo \"\$kak_selections\"      > selections
        echo \"\$kak_selections_desc\" > state
        }
        write out
        quit!
      "
      kak out -n -e $kak_commands
      IFS=$'\n'
      for expect in $test_files; do
        if cmp --quiet $test/$dir/$expect $expect; then
          echo "$indent$name" | colorize green normal
        else
          ((number_failures++))
          echo "$indent$name" | colorize red normal
          echo
          IFS=$'\n'
          for line in $(diff --unified $test/$dir/$expect $expect); do
            IFS=¬
            local first_character=$(echo "$line" | head --bytes 1)
            local color=$(match $first_character + green - red @ magenta none)
            echo "$line" | colorize $color normal
          done
          echo
          echo "debug buffer:" | colorize yellow normal
          cat debug
          echo
        fi
      done
    fi
  done
  if (( $number_failures > 0 )); then
    color=red
  else
    color=green
  fi
  echo
  echo Resume:
  echo $number_tests tests, $number_failures failures | colorize $color normal
}

# Utility ├─────────────────────────────────────────────────────────────────────

match() {
  expression="$1";
  shift
  while [[ "$@" ]]; do
    local pattern="$1"
    shift
    local value="$1"
    local next="$1"
    local default_value="$pattern"
    if [[ -z "$next" ]]; then
      echo $default_value
      return 1
    fi
    if [[ "$expression" = "$pattern" ]]; then
      echo "$value"
      return 0
    fi
    shift
  done
}

repeat() {
  local text=$1
  local count=${2:-0}
  echo $(yes $text | head --lines $count | join)
}

join() {
  tr --delete "\n"
}

exists() {
  test -e $@
}

get_ansi_code() {
  local color_name=${1:-none}
  local style_name=${2:-none}
  local color='none    00
               red     31
               green   32
               yellow  33
               magenta 35'
  local style='none    00
               bold    01'
  local color_nr=$(echo "$color" | awk "/$color_name/ { print \$2 }")
  local style_nr=$(echo "$style" | awk "/$style_name/ { print \$2 }")
  echo '\e[STYLE_NR;COLOR_NRm' | sed s/COLOR_NR/$color_nr/';'s/STYLE_NR/$style_nr/
}

colorize() {
  local text=$(cat)
  local color_name=${1:-none}
  local style_name=${2:-none}
  echo -e "$(get_ansi_code $color_name $style_name)$text$(get_ansi_code none none)"
}


main $@
