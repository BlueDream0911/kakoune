.TH KAKOUNE 1 "" "" "SHORTCUTS"

.SS Insert mode
.TP
.BR <esc>
leave insert mode
.TP
.BR <backspace>
delete characters before cursors
.TP
.BR <del>
delete characters under cursors
.TP
.BR <left>,\ <right>,\ <up>,\ <down>
move the cursors in given direction
.TP
.BR <home>
move cursors to line begin
.TP
.BR <end>
move cursors to end of line
.TP
.BR <c-n>
select next completion candidate
.TP
.BR <c-p>
select previous completion candidate
.TP
.BR <c-x>
explicit insert completion query, followed by:
.RS 7
.TP
.BR f
explicit file completion
.TP
.BR w
explicit word completion
.TP
.BR l
explicit line completion
.RE
.TP
.BR <c-o>
disable automatic completion for this insert session
.TP
.BR <c-r>
insert contents of the register given by next key
.TP
.BR <c-v>
insert next keystroke directly into the buffer, without interpreting it
.TP
.BR <c-u>
commit changes up to now as a single undo group
.TP
.BR <a-;>
escape to normal mode for a single command

.SS Movement
"word" is a sequence of alphanumeric characters or underscore, and "WORD" is a sequence of non whitespace characters

.TP
.BR h
select the character on the left of selection end
.TP
.BR j
select the character below the selection end
.TP
.BR k
select the character above the selection end
.TP
.BR l
select the character on the right of selection end
.TP
.BR w
select the word and following whitespaces on the right of selection end
.TP
.BR b
select preceding whitespaces and the word on the left of selection end
.TP
.BR e
select preceding whitespaces and the word on the right of selection end
.TP
.BR <a-[wbe]>
same as [wbe] but select WORD instead of word
.TP
.BR f
select to the next occurence of given character
.TP
.BR t
select until the next occurence of given character
.TP
.BR <a-[ft]>
same as [ft] but in the other direction
.TP
.BR m
select to matching character
.TP
.BR M
extend selection to matching character
.TP
.BR x
select line on which selection end lies (or next line when end lies on an end-of-line)
.TP
.BR <a-x>
expand selections to contain full lines (including end-of-lines)
.TP
.BR <a-X>
trim selections to only contain full lines (not including last end-of-line)
.TP
.BR %
select whole buffer
.TP
.BR <a-h>
select to line begin
.TP
.BR <a-l>
select to line end
.TP
.BR /
search (select next match)
.TP
.BR <a-/>
search (select previous match)
.TP
.BR ?
search (extend to next match)
.TP
.BR <a-?>
search (extend to previous match)
.TP
.BR n
select next match
.TP
.BR N
add a new selection with next match
.TP
.BR <a-n>
select previous match
.TP
.BR <a-N>
add a new selection with previous match
.TP
.BR pageup
scroll up
.TP
.BR pagedown
scroll down
.TP
.BR '
rotate selections (the main selection becomes the next one)
.TP
.BR ;
reduce selections to their cursor
.TP
.BR <a-;>
flip the selections direction
.TP
.BR <a-:>
ensure selections are in forward direction (cursor after anchor)

.SS Changes
.TP
.BR i
enter insert mode before current selection
.TP
.BR a
enter insert mode after current selection
.TP
.BR d
yank and delete current selection
.TP
.BR c
yank and delete current selection and enter insert mode
.TP
.BR .
repeat last insert mode change (`i`, `a`, or `c, including the inserted text)
.TP
.BR I
enter insert mode at current selection begin line start
.TP
.BR A
enter insert mode at current selection end line end
.TP
.BR o
enter insert mode in a new line below current selection end
.TP
.BR O
enter insert mode in a new line above current selection begin
.TP
.BR y
yank selections
.TP
.BR p
paste after current selection end
.TP
.BR P
paste before current selection begin
.TP
.BR <a-p>
paste all after current selection end, and select each pasted string
.TP
.BR <a-P>
paste all before current selection begin, and select each pasted string
.TP
.BR R
replace current selection with yanked text
.TP
.BR r
replace each character with the next entered one
.TP
.BR <a-j>
join selected lines
.TP
.BR <a-J>
join selected lines and select spaces inserted in place of line breaks
.TP
.BR >
indent selected lines
.TP
.BR <a->>
indent selected lines, including empty lines
.TP
.BR <
deindent selected lines
.TP
.BR <a-<>
deindent selected lines, do not remove incomplete indent (3 leading spaces when indent is 4)
.TP
.BR !
insert command output before selection
.TP
.BR a-!
append command output after selection
.TP
.BR u
undo last change
.TP
.BR U
redo last change
.TP
.BR &
align selection, align the cursor of selections by inserting spaces before the first character of the selection
.TP
.BR <a-&>
copy indent, copy the indentation of the main selection (or the count one if a count is given) to all other ones
.TP
.BR `
to lower case
.TP
.BR ~
to upper case
.TP
.BR <a-`>
swap case
.TP
.BR @
convert tabs to spaces in current selections, uses the buffer tabstop option or the count parameter for tabstop
.TP
.BR <a-@>
convert spaces to tabs in current selections, uses the buffer tabstop option or the count parameter for tabstop
.TP
.BR <a-'>
rotate selections content, if specified, the count groups selections, so
.IR 3<a-'>
rotate (1, 2, 3) and (3, 4, 6) independently

.SS Goto Commands
If a count is given prior to hitting `g`, `g` will jump to the given line

.TP
.BR gh
select to line begin
.TP
.BR gl
select to line end
.TP
.BR gg,\ gk
go to the first line
.TP
.BR gj
go to the last line
.TP
.BR ge
go to last char of last line
.TP
.BR gt
go to the first displayed line
.TP
.BR gc
go to the middle displayed line
.TP
.BR gb
go to the last displayed line
.TP
.BR ga
go to the previous (alternate) buffer
.TP
.BR gf
open the file whose name is selected
.TP
.BR g.
go to last buffer modifiction position

.SS View commands
.TP
.BR V
lock view mode until <esc> is hit
.TP
.BR vv,\ vc
center the main selection in the window
.TP
.BR vt
scroll to put the main selection on the top line of the window
.TP
.BR vb
scroll to put the main selection on the bottom line of the window
.TP
.BR vh
scroll the window count columns left
.TP
.BR vj
scroll the window count line downward
.TP
.BR vk
scroll the window count line upward
.TP
.BR vl
scroll the window count columns right


.SS Marks
Marks use the
.IR ^
register by default
.TP
.BR Z
will save the current selections to the register
.TP
.BR z
will restore the selections from the register
.TP
.BR <a-z>
will add the selections from the register to the existing ones

.SS Macros
Macros use the
.IR @
register by default
.TP
.BR Q
record a macro
.TP
.BR q
play a recorded macro

.SS Searching
Searches use the
.IR /
register by default
.TP
.BR *
set the search pattern to the current selection (automatically detects word boundaries)
.TP
.BR <a-*>
set the search pattern to the current selection (verbatim, no smart detection)

.SS Jump list
.TP
.BR <c-i>
Jump forward
.TP
.BR <c-o>
Jump backward
.TP
.BR <c-s>
save current selections

.SS Multiple selections
.TP
.BR s
create a selection
.TP
.BR <a-s>
split the current selections on line boundaries
.TP
.BR S
split the current selection
.TP
.BR C
copy the current selection to the next line
.TP
.BR <a-C>
copy the current selection to the previous line
.TP
.BR <space>
clear a multiple selection
.TP
.BR <a-space>
clear the current selection
.TP
.BR <a-k>
keep the selections that match the given regex
.TP
.BR <a-K>
clear selections that match the given regex
.TP
.BR |
pipe each selection through the given external filter program and replace the selection with its output
.TP
.BR <a-|>
pipe each selection through the given external filter program and ignore its output
.TP
.BR $
pipe each selection to the given shell command

.SS Object Selection
.TP
.BR <a-a>
selects the whole object
.TP
.BR <a-i>
selects the inner object, that is the object excluding it's surrounder
.TP
.BR [
selects to object start
.TP
.BR ]
selects to object end
.TP
.BR {
extends selections to object start
.TP
.BR }
extends selections to object end
.RE

After this key, you need to enter a second key in order to specify which object you want
.TP
.BR b,\ (,\ )
select the enclosing parenthesis
.TP
.BR B,\ {,\ }
select the enclosing {} block
.TP
.BR r,\ [,\ ]
select the enclosing [] block
.TP
.BR a,\ <,\ >
select the enclosing <> block
.TP
.BR "
select the enclosing double quoted string
.TP
.BR '
select the enclosing single quoted string
.TP
.BR `
select the enclosing grave quoted string
.TP
.BR w
select the whole word
.TP
.BR W
select the whole WORD
.TP
.BR s
select the sentence
.TP
.BR p
select the paragraph
.TP
.BR ‚ê£
select the whitespaces
.TP
.BR i
select the current indentation block
.TP
.BR n
select the number
.TP
.BR :
select user defined object, will prompt for open and close text

.SS Prompt Commands
.TP
.BR <ret>
validate prompt
.TP
.BR <esc>
abandon without
.TP
.BR <left>,\ <a-h>
move cursor to previous character
.TP
.BR <right>,\ <a-l>
move cursor to previous character
.TP
.BR <home>
move cursor to first character
.TP
.BR <end>
move cursor to passed last character
.TP
.BR <backspace>,\ <a-x>
erase character before cursor
.TP
.BR <del>,\ <a-d>
erase character under cursor
.TP
.BR <c-w>
avance to next word begin
.TP
.BR <c-a-w>
advance to next WORD begin
.TP
.BR <c-b>
go back to previous word begin
.TP
.BR <c-a-b>
go back to previous WORD begin
.TP
.BR <c-e>
advance to next word end
.TP
.BR <c-a-e>
advance to next word end
.TP
.BR <up>,\ <c-p>
select previous entry in history
.TP
.BR <down>,\ <c-n>
select next entry in history
.TP
.BR <tab>
select next completion candidate
.TP
.BR <backtab>
select previous completion candidate
.TP
.BR <c-r>
insert then content of the register given by next key
.TP
.BR <c-v>
insert next keystroke without interpretting it
.TP
.BR <c-o>
disable auto completion for this prompt

.SS Key mapping
Mapping a combination of keys to another one (a.k.a. key mapping or binding) can be done with the following command:

.TP
.BR map " <scope> <mode> <key> <keys>"
.RS 3
.TP
.BR scope
can be one of
.IR global ", " window " or " buffer
.TP
.BR mode
can be one of
.IR insert ", " normal ", " prompt ", " menu ", " user
or a one character long arbitrary prefix (the
.IR user
mode uses the
.IR ,
prefix)
.TP
.BR key
the key to which the combination will be bound
.TP
.BR keys
string that lists the keys that will be executed when
.IR key
is hit
.RE

Keys are always executed within the
.IR normal
mode
