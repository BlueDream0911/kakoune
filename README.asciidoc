Kakoune
=======

Introduction:
-------------

Kakoune is a code editor heavily inspired by vim, as such most of it's
commands are similar to vi's ones.

Kakoune can operate in two modes, normal and insertion. In insertion mode,
keys are directly inserted into the current buffer. In normal mode, keys
are used to manipulate the current selection and to enter insertion mode.

There is no concept of cursor in kakoune, only selections, a single character
selection can be seen as a cursor but there is no difference internally.

Building
--------

Kakoune dependencies are:

 * GCC >= 4.6
 * boost
 * ncurses

To build, just type *make* in the src directory

Basic Movement
--------------

 * _space_: select the character under selection end

 * _h_: select the character on the right of selection end
 * _j_: select the character below the selection end
 * _k_: select the character above the selection end
 * _l_: select the character on the left of selection end

 * _w_: select the word and following whitespaces  on the right of selection end
 * _b_: select preceding whitespaces and the word on the left of selection end
 * _e_: select preceding whitespaces and the word on the right of selection end

 * _x_: select line on which selection end lies (or next line when end lies on
        an end-of-line)
 * _alt-x_: expand selections to contain full lines (including end-of-lines)

 * _%_: select whole buffer

 * _gh_, _alt-H_: select to line begin
 * _gl_, _alt-L_: select to line end

 * _gg_, _gt_: go to the first line
 * _gb_: go to the last line

Appending
---------

for most selection commands, using shift permits to add to current selection
instead of replacing it. for example, _wWW_ selects 3 consecutive words

Using Counts
------------

Most selection commands also support counts, which are entered before the
command itself.

for example, _3W_ selects 3 consecutive words and _3w_ select the third word on
the right of selection end.

* _space_: when used with count, keep only the counth selection
* _alt-space_: when used with count, remove the counth selection

Changes
-------

 * _i_: insert before current selection
 * _a_: insert after current selection
 * _d_: yank and delete current selection
 * _c_: yank and delete current selection and insert

 * _I_: insert at current selection begin line start
 * _A_: insert at current selection end line end
 * _o_: insert in a new line below current selection end
 * _O_: insert in a new line above current selection begin

 * _p_: paste after current selection end
 * _P_: paste before current selection begin

 * _alt-j_: join selected lines

 * _|_: pipe each selections through the given external filter program
        and replace with it's output.

Multi Selection
---------------

Kak was designed from the start to handle multiple selections.
On way to get a multiselection is via the _s_ key.

For example, to change all occurences of word 'roger' to word 'marcel'
in a paragraph, here is what can be done:

select the paragraph with enough _x_. press _s_ and enter roger then enter.
now paragraph selection was replaced with multiselection of each roger in
the paragraph. press _c_ and marcel<esc> to replace rogers with marcels.

A multiselection can also be obtained with _Alt-s_, which splits the current
selection according to the regex entered. To split a comma separated list,
use _alt-s_ then ', *'

To clear multiple selections, use _space_. To keep only the nth selection
use _n_ followed by _space_.

Object Selection
----------------

Using alt-i and alt-a, you can select some text object, the starting
point is always the last character of the selection.

* _b_, _(_ or _)_: select the enclosing parenthesis
* _B_, _{_ or _}_: select the enclosing {} block
* _[_ or _]_: select the enclosing [] block
* _<_ or _>_: select the enclosing <> block
* w: select the whole word
* W: select the whole WORD

When it makes sense, alt-i selects the inner object and alt-a the whole
object. For example alt-i ( will only select the inside of the parenthesis.

Registers
---------

registers are named list of text. They are used for various purpose, like
storing the last yanked test, or the captures groups associated with the
last selection.

While in insert mode, ctrl-r followed by a register name (one character)
inserts it.

For example, ctrl-r followed by " will insert the currently yanked text.
ctrl-r followed by 2 will insert the second capture group from the last regex
selection.

Registers are lists, instead of simply text in order to interact well with
multiselection. Each selection have it's own captures, or yank buffer.

Highlighters
------------

Manipulation of the displayed text is done through highlighters, which can be added
or removed with the command :addhl <highlighter_name> <highlighter_parameters...>
and :rmhl <highlighter_id>

existing highlighters are:

* *highlight_selections*: used to make current selection visible
* *expand_tabs*: expand tabs to next 8 multiple column (to make configurable)
* *number_lines*: show line numbers
* *regex*: highlight a regex, takes 3 parameters <regex> <fg_color> <bg_color>
* *group*: highlighter group, containing other highlighters. takes one
           parameter, <group_name>. useful when multiple highlighters work
           together and need to be removed as one. Adding and removing from
           a group can be done using
           :addhl -group <group> <highlighter_name> <highlighter_parameters...>
           :rmhl  -group <group> <highlighter_name>

Filters
-------

Filters can be installed to interact with buffer modifications. They can be
added or removed with :addfilter <filter_name> <filter_parameters...> and
:rmfilter <filter_id>

exisiting filters are:

* *preserve_indent*: insert previous line indent when inserting a newline
* *cleanup_whitespaces*: remove trailing whitespaces on the previous line
                         when inserting an end-of-line.
* *expand_tabulations*: insert spaces instead of tab characters

Hooks
-----

commands can be registred to be executed when certain events arise.
to register a hook, use the hook command.

:hook <scope> <hook_name> <filtering_regex> <command> <command_args>...

<scope> can be either global or window, as hooks can be registered per
window.

for example, to automatically use line numbering with .cc files,
use the following command:

:hook global WinCreate .*\.cc addhl number_lines

Shell expension
---------------

Commands support the shell backtick syntax, and kakoune internal state
can be accessed through environment variable. For example, if you are
editing the editor.cc file, typing ':edit `echo ${kak_bufname/%.cc/.hh}`'
will edit the editor.hh file.

